#ifdef WINDOWS_MOBILE

#include "Config.h"

#if defined(HAS_MULTIPLAYER) && defined(_WINDOWS)


#include <stdio.h>
#include <stdlib.h>

#include <memory.h>
#include "memoryallocation.h"
#include "WinBlue.h"
#include <BthUtil.h>

#include "hg/HighGear.h"


void debug_out(const char* x, ...);

//SDP record generated by bthnscreate.exe
BYTE rgbSdpRecord[] = {
         0x35, 0x4d, 0x09, 0x00, 0x01, 0x35, 0x11, 0x1c,
         0x29, 0xf9, 0xc0, 0xfd, 0xbb, 0x6e, 0x47, 0x97,
         0x9f, 0xa9, 0x3e, 0xc9, 0xa8, 0x54, 0x29, 0x0c,
         0x09, 0x00, 0x04, 0x35, 0x0c, 0x35, 0x03, 0x19,
         0x01, 0x00, 0x35, 0x05, 0x19, 0x00, 0x03, 0x08,
         0x1a, 0x09, 0x00, 0x06, 0x35, 0x09, 0x09, 0x65,
         0x6e, 0x09, 0x00, 0x6a, 0x09, 0x01, 0x00, 0x09,
         0x00, 0x09, 0x35, 0x08, 0x35, 0x06, 0x19, 0x11,
         0x05, 0x09, 0x01, 0x00, 0x09, 0x01, 0x00, 0x25,
         0x06, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c
};

//server GUID
WCHAR strGUID[]=L"29F9C0FD-BB6E-4797-9FA9-3EC9A854290C";

//SDP record size constant returned by bthnscreate.exe
#define SDP_RECORD_SIZE 0x0000004f
#define SDP_CHANNEL_OFFSET 40


// constructor
CWinBlue::CWinBlue()
{
	debug_out("CWinBlue:: constructor");

	ListenSocket = INVALID_SOCKET;
	for (int i = 0; i < DEVICE_MAX; i++)
		DataSocket[i] = INVALID_SOCKET;

	state = STATE_NONE_B;

	int iResult = WSAStartup(MAKEWORD(2,2), &wsaData);
	if (iResult != 0)
		debug_out("CWinBlue::CWinBlue: WSAStartup failed: %d\n", iResult);
}

// update
bool CWinBlue::update()
{
	switch(state)
	{
		case STATE_ACCEPT_B:
		{
			fd_set setR;
			timeval tval = {0, 0};
			FD_ZERO(&setR);
			FD_SET(ListenSocket, &setR);
			int iResult = select(1, &setR, NULL, NULL, &tval);

			if (iResult == SOCKET_ERROR)
			{
				int error = WSAGetLastError();
				debug_out("CWinBlue::update accept: error=%d\n", error);
				CleanUp();
				return false;
			}
			else if (iResult == 0)
			{
				break;
			}

			if (FD_ISSET(ListenSocket, &setR))
			{
				debug_out("CWinBlue::update listen 1\n");
				int devIdx = CHighGear::GetInstance()->device_to_confirm_nb;

				SOCKADDR_BTH addr;
				int addrLen = sizeof(addr);
				
				// Accept a client socket
				DataSocket[0] = accept(ListenSocket, (sockaddr*) &addr, &addrLen);
				if ( DataSocket[0] == INVALID_SOCKET)
				{
					debug_out("CWinBlue::update accept: accept %d\n", WSAGetLastError());
					return false;
				}

				DeviceDetails* dd = NEW DeviceDetails();

				//dd->iAddress = NEW char[sizeof(struct sockaddr)];
				//memcpy(dd->iAddress, &addr, sizeof(struct sockaddr));

				dd->iAddress = NEW char[sizeof(bt_addr)];
				memcpy(dd->iAddress, 
						&addr, 
						sizeof(bt_addr));

				//get the name of the bluetooth that wants to conect to me
				//int j=0;
				//while(pwsaResults->lpszServiceInstanceName[j]!='\0')
				//{
				//    dd->iName[j + 4] += pwsaResults->lpszServiceInstanceName[j];
				//    j++;
				//}
				//dd->iName[j + 4] = '\0';

				// we must receive the client name
				iResult = recv(DataSocket[devIdx], (char *)dataBuff, DATA_BUFF_SIZE, 0);
				if (iResult == -1)
				{
					debug_out("CWinBlue::DeviceReceive: recv error %d\n", WSAGetLastError());
					CleanUp();
					return false;
				}
				iResult = iResult < sizeof(dd->iName) ? iResult : sizeof(dd->iName) - 1;
				memcpy(dd->iName, dataBuff, iResult);
				dd->iName[iResult] = 0; // adding null terminator

				debug_out("CWinBlue::update listen 3\n");

				Connected(0);
				CHighGear::GetInstance()->ConfirmRemoteDevice(dd);
				state = 0;
			}

			//if (FD_ISSET(DiscoverSocket, &setR))
			//{
			//	debug_out("CWinBlue::update discover 1\n");

			//	struct sockaddr addr;
			//	int addrLen = sizeof(struct sockaddr);

			//	int len = recvfrom(DiscoverSocket, (char*)dataBuff, DATA_BUFF_SIZE, 0, &addr, &addrLen);
			//	if (len == SOCKET_ERROR)
			//	{
			//		debug_out("CWinBlue::Error when receiving data with udp socket: %d\n", WSAGetLastError());
			//		CleanUp();
			//		return false;
			//	}

			//	debug_out("CWinBlue::update discover 2\n");

			//	dataBuff[len] = 0;	// adding 0 terminator

			//	// checking signature
			//	if (strcmp(m_pPrefix, (char*)dataBuff) == 0)
			//	{
			//		debug_out("CWinBlue::update discover 3\n");

			//		// sending response to client
			//		if (sendto(DiscoverSocket, (char*)dataBuff, len, 0, &addr, addrLen) == SOCKET_ERROR)
			//		{
			//			debug_out("CWinBlue::Error when responding using udp socket: %d\n", WSAGetLastError());
			//			CleanUp();
			//			return false;
			//		}

			//		debug_out("CWinBlue::update discover 4\n");
			//	}
			//}

			break;
		}
		case STATE_DISCOVER_B:
		{
			int iResult;
			if (scanState == 0)
			{
				union {
					CHAR buf[5000];				// returned struct can be quite large 
					SOCKADDR_BTH	__unused;	// properly align buffer to BT_ADDR requirements
				};
				
					//LPWSAQUERYSET	pwsaResults;
					//DWORD			dwSize = 0;

					pwsaResults = (LPWSAQUERYSET) buf;
					dwSize  = sizeof(buf);
					
					memset(pwsaResults,0,sizeof(WSAQUERYSET));
					pwsaResults->dwSize      = sizeof(WSAQUERYSET);
					// namespace MUST be NS_BTH for bluetooth queries
					pwsaResults->dwNameSpace = NS_BTH;
					pwsaResults->lpBlob      = NULL;
					
					// iterate through all found devices, returning name and address
					// (this sample only uses the name, but address could be used for
					// further queries)
					//iResult = ScanForNextDevice();
					DWORD id;
					scanState = 1;
					CreateThread(NULL,0,ScanForNextDevice, (void *)this,0,&id);
					
					//scanState is set to 2 inside the thread
			}
			if (scanState == 2)
			{
				//scanResult should be set inside the thread
				iResult = scanResult;
				scanResult = -1;

				if (iResult != 0)
				{
					iResult = WSAGetLastError();
					if (iResult != WSA_E_NO_MORE)
					{
						debug_out("another little error");				
					}
					// we're finished
					scanState = -1;
					state = -1;
					WSALookupServiceEnd(hLookup);
					break;
				}
				
				scanState = 0;

				// add the name to the listbox
				if (pwsaResults->lpszServiceInstanceName)
				{
					// checking signature
					//if (strcmp(m_pPrefix, (char*) pwsaResults->lpszServiceInstanceName) == 0)
					//for (int xyz = 0; xyz < 10; xyz ++)
					{
						DeviceDetails* dd = NEW DeviceDetails();

						//dd->iAddress = NEW char[sizeof(struct sockaddr)];
						//memcpy(dd->iAddress, &addr, sizeof(struct sockaddr));
						dd->iAddress = NEW char[sizeof(bt_addr)];
						memcpy(dd->iAddress, 
								&((SOCKADDR_BTH *) pwsaResults->lpcsaBuffer->RemoteAddr.lpSockaddr)->btAddr, 
								sizeof(bt_addr));

						int j=0;
						dd->iName[0] = 'A';
						dd->iName[1] = 'A';
						dd->iName[2] = 'A';
						dd->iName[3] = 'A';
						while(pwsaResults->lpszServiceInstanceName[j]!='\0')
						{
							dd->iName[j + 4] += pwsaResults->lpszServiceInstanceName[j];
							j++;
						}
						dd->iName[j + 4] = '\0';

						debug_out("CWinBlue::Server name = %s\n", dd->iName);

						int save = m_iDevicesCount;
						AddDevice(dd);
						//dealloc dd, since it could not be added.
						//if (save == m_iDevicesCount)
						//{
						//	SAFE_DELETE(dd->iAddress);
						//	dd->iAddress = NULL;	
						//	SAFE_DELETE(dd);
						//}
					}	
				}
			}
				
			break;
		}
		case STATE_RECV_DATA_B:
		{
			int i;

			fd_set setR;
			timeval tval = {0, 0};
			FD_ZERO(&setR);
			for (i = 0; i < m_iDevicesCount; i++)
				FD_SET(DataSocket[i], &setR);

			int iResult = select(m_iDevicesCount, &setR, NULL, NULL, &tval);
			if (iResult == SOCKET_ERROR)
			{
				debug_out("CWinBlue::DeviceReceive: select error %d\n", WSAGetLastError());
				CleanUp();
				return false;
			}

		//	debug_out("CWinBlue::DeviceReceive select returns : %d\n", iResult);
			if (iResult == 0)
				break;

			for (i = 0; i < m_iDevicesCount; i++)
			{
				if (FD_ISSET(DataSocket[i], &setR))
				{
					iResult = recv(DataSocket[i], (char *)dataBuff, DATA_BUFF_SIZE, 0);
					if (iResult == -1)
					{
						debug_out("CWinBlue::DeviceReceive: recv error %d\n", WSAGetLastError());
						CleanUp();
						return false;
					}

					if (iResult > 0)
					{
//						// ignoring disconnected devices
//						if (m_bDevicesCnx[i])
						{
							//debug_out("CWinBlue::OnDataRecv: type = %d len = %d clientId = %d\n", dataBuff[0], iResult, i);
							if (!OnDataRecv(dataBuff, iResult, i))
							{
								debug_out("CWinBlue::Queue overflow !!!\n");
								return false;
							}
						}
					}
					else if (iResult == 0)
					{
						// connection closed
						m_iDevicesConnected--;

						if (m_iDevicesConnected == 0)
							isConnected = false;

						// set connexion state of the device
						m_bDevicesCnx[i] = false;

						debug_out("CWinBlue:: Connection closed by device %d\n", i);
					}
				}
			}

			break;
		}
	}

	return true;
}

// hosts search
bool CWinBlue::DiscoverServers()
{
	debug_out("CWinBlue::DiscoverServers\n");

	//search for active servers
	INT				iResult = 0;
	DWORD			dwSize = 0;

	hLookup = 0;

	WSAQUERYSET		wsaq;
	memset (&wsaq, 0, sizeof(wsaq));
	wsaq.dwSize      = sizeof(wsaq);
	wsaq.dwNameSpace = NS_BTH;
	wsaq.lpcsaBuffer = NULL;


	//BTHNS_RESTRICTIONBLOB RBlob;
	//memset (&RBlob, 0, sizeof(RBlob));
	//RBlob.type = SDP_SERVICE_SEARCH_REQUEST;
	//RBlob.uuids[0].uuidType = SDP_ST_UUID16;
	//RBlob.uuids[0].u.uuid16 = 123;

	//BLOB blob;
	//blob.cbSize = sizeof(RBlob);
	//blob.pBlobData = (BYTE *)&RBlob;

	//wsaq.lpBlob      = &blob;


	// initialize searching procedure
	iResult = WSALookupServiceBegin(&wsaq, 
		LUP_CONTAINERS, 
		&hLookup);
	if (iResult != 0)
	{
		debug_out("Little error %d", WSAGetLastError());
	}
	state = STATE_DISCOVER_B;
	scanResult = -1;
	scanState = 0;

	return true;
}

// connections
bool CWinBlue::StartServer()
{
	debug_out("CWinBlue::StartServer\n");
	isServer = true;

	if(ListenSocket==INVALID_SOCKET)
	{
		ListenSocket = socket (AF_BT, SOCK_STREAM, BTHPROTO_RFCOMM);
		if (ListenSocket  == INVALID_SOCKET) 
		{
			debug_out("CWinBlue::StartServer: socket %d\n", WSAGetLastError());
			return false;
		}
	
		SOCKADDR_BTH sa;
		memset (&sa, 0, sizeof(sa));
		sa.addressFamily = AF_BT;
		sa.port = 0;
		if (bind (ListenSocket, (SOCKADDR *)&sa, sizeof(sa))) 
		{
			debug_out("CWinBlue::StartServer: bind %d\n", WSAGetLastError());
			return false;
		}
		int iNameLen = sizeof(sa);
		if (getsockname(ListenSocket, (SOCKADDR *)&sa, &iNameLen))	
		{
			debug_out("CWinBlue::StartServer: getsockname %d\n", WSAGetLastError());
			return false;

		}

		if(RegisterService(rgbSdpRecord, SDP_RECORD_SIZE, SDP_CHANNEL_OFFSET, (UCHAR)sa.port)!=0)
		{
			debug_out("CWinBlue::StartServer: register service %d\n", WSAGetLastError());
			return false;
		}

		if (listen (ListenSocket, SOMAXCONN)) 
		{
			debug_out("CWinBlue::StartServer: listen %d\n", WSAGetLastError());
			return false;
		}

		//SOCKADDR_BTH addr;
		//int addrLen = sizeof(addr);
		//
		//// Accept a client socket
		//DataSocket[0] = accept(ListenSocket, (sockaddr*) &addr, &addrLen);
		//if ( DataSocket[0] == INVALID_SOCKET)
		//{
		//	debug_out("CWinBlue::StartServer: accept %d\n", WSAGetLastError());
		//	return false;
		//}
	}


	state = STATE_ACCEPT_B;

	return true;
}

void CWinBlue::StopListening()
{
	debug_out("CWinBlue::StopListening\n");

	closesocket(ListenSocket);
	ListenSocket = INVALID_SOCKET;

	state = STATE_RECV_DATA_B;
}

bool CWinBlue::StartClient()
{
	debug_out("CWinBlue::StartClient\n");
	isServer = false;
	return true;
}

// connection
bool CWinBlue::Connect(int serverIdx)
{
	if (isServer)
		return false;

	debug_out("CWinBlue::Connect to server %d\n", serverIdx);

	bt_addr adresa;
	int iResult;

	isConnecting = true;

	memcpy(&adresa,
			m_pDevices[serverIdx]->iAddress, 
			sizeof(bt_addr));

	//clean
	for (int i = m_iDevicesCount - 1; i >= 0; i--)
	{
		closesocket(DataSocket[i]);
		DataSocket[i] = INVALID_SOCKET;

		if (i != serverIdx)
			RemoveDevice(i);
	}

	GUID ServerGuid;
	if(GetGUID(strGUID, &ServerGuid))
	{
		isConnecting = false;
		return false;
	}
	DataSocket[0] = socket(AF_BT, SOCK_STREAM, BTHPROTO_RFCOMM);
	if (DataSocket[0] == INVALID_SOCKET)
	{
		isConnecting = false;
		debug_out("CWinBlue::ConnectLoop Error at socket(): %ld\n", WSAGetLastError());
		CleanUp();
		return false;
	}


	SOCKADDR_BTH sa;
	memset (&sa, 0, sizeof(sa));
	sa.addressFamily = AF_BT;
	sa.serviceClassId=ServerGuid;
	sa.btAddr = adresa;


	// Connect to server.
	iResult = connect(DataSocket[0], (SOCKADDR *)&sa, sizeof(SOCKADDR_BTH));
	if (iResult == SOCKET_ERROR)
	{
		isConnecting = false;
		int err = WSAGetLastError();
		debug_out("CWinBlue::ConnectLoop Error connect: %d\n", WSAGetLastError());
		CleanUp();
		return false;
	}

	Connected(0);

	iResult = send(DataSocket[0], m_pLocalDeviceName, strlen(m_pLocalDeviceName),0);
	if (iResult == SOCKET_ERROR)
	{
		isConnecting = false;
		int err = WSAGetLastError();
		debug_out("CWinBlue::ConnectLoop Error send name: %d\n", WSAGetLastError());
		CleanUp();
		return false;
	}

	state = STATE_RECV_DATA_B;
	return true;
}

void CWinBlue::Disconnect(int)
{
	debug_out("CWinBlue::Disconnect\n");

	for (int i = 0; i < m_iDevicesCount; i++)
	{
	    if( DataSocket[i] != INVALID_SOCKET )
	    {
		    closesocket(DataSocket[i]);
		    DataSocket[i] = INVALID_SOCKET;
		}
	}

    if( ListenSocket != INVALID_SOCKET )
    {
	    closesocket(ListenSocket);
	    ListenSocket = INVALID_SOCKET;
	}

	ClearDevicesList();
}

// send/receive data
bool CWinBlue::SendData(unsigned char* data, unsigned int  dataLen, unsigned char  clientId)
{
	if (clientId == CLIENT_ID_ALL)
	{
		bool error = false;
		for (int clId = 0; clId < m_iDevicesCount; clId++)
		{
			if (!SendData(data, dataLen, clId))
				error = true;
		}

		return !error;
	}
	else
	{
		//debug_out("CWinBlue::SendData: type = %d len = %d clientId = %d\n", data[0], dataLen, clientId);

		fd_set setW;
		timeval tval = {0, 0};
		FD_ZERO(&setW);
		FD_SET(DataSocket[clientId], &setW);

		int iResult = select(1, NULL, &setW, NULL, NULL);
		if (iResult == SOCKET_ERROR)
		{
			debug_out("CWinBlue::DeviceSend: select error %d\n", WSAGetLastError());
			CleanUp();
			return false;
		}

		iResult = send(DataSocket[clientId], (const char *)data, dataLen, 0);
		if (iResult == SOCKET_ERROR)
		{
			debug_out("CWinBlue::DeviceSend send failed: %d\n", WSAGetLastError());
			CleanUp();
			return false;
		}
	}

	return true;
}

// local device name
char* CWinBlue::GetLocalDeviceName()
{
	if (m_pLocalDeviceName[0] == 0)
	{
		if (gethostname(m_pLocalDeviceName, LOCAL_DEVICE_NAME_SIZE) == SOCKET_ERROR)
		{
			debug_out ("Error %d when getting local host name.", WSAGetLastError());
			m_pLocalDeviceName[0] = 0; // empty string
		}
	}

	return m_pLocalDeviceName;
}

void CWinBlue::SetLocalDeviceName(char* name)
{
	strcpy(m_pLocalDeviceName, name);
}

bool CWinBlue::IsConnectionAvailable()
{
	return true;
}

void CWinBlue::CleanUp()
{
	for (int i = 0; i < DEVICE_MAX; i++)
	{
		closesocket(DataSocket[i]);
		DataSocket[i] = INVALID_SOCKET;
	}

	closesocket(ListenSocket);
	ListenSocket = INVALID_SOCKET;

	WSACleanup();
}

void CWinBlue::RemoveDevice(unsigned int deviceId)
{
//	freeaddrinfo((struct addrinfo *)m_pDevices[deviceId]->iAddress);
//	m_pDevices[deviceId]->iAddress = NULL;

	Comms::RemoveDevice(deviceId);
}

// destructor
CWinBlue::~CWinBlue()
{
	CleanUp();
	debug_out("CWinBlue:: destructor");
}


bool CWinBlue::GetPowerState()
{
	DWORD mode;
	BthGetMode(&mode);
	if (mode == BTH_DISCOVERABLE)
	{	
		return true;
	}
	return false;
}

void CWinBlue::SetPowerState(bool state)
{
	int ok = BthSetMode(BTH_DISCOVERABLE);
}


//Function: RegisterService
//Purpose:	Publishes the SDP record.
//Input:	The SDP record of the service to register, size of the SDP record, channel offset in the record, channel number assigned automatically by OpenServerConnection
//Return: If error occurs, returns the appropriate WSAGetLastError, otherwise returns zero.

int CWinBlue::RegisterService(BYTE *rgbSdpRecord, int cSdpRecord, int iChannelOffset, UCHAR channel)
{
		ULONG recordHandle = 0;
	
	struct bigBlob
	{
		BTHNS_SETBLOB   b;

	}*pBigBlob;

	pBigBlob = (bigBlob *)malloc(sizeof(struct bigBlob)+cSdpRecord);
	ULONG ulSdpVersion = BTH_SDP_VERSION;
	pBigBlob->b.pRecordHandle   = &recordHandle;
	pBigBlob->b.pSdpVersion     = &ulSdpVersion;
	pBigBlob->b.fSecurity       = 0;
	pBigBlob->b.fOptions        = 0;
	pBigBlob->b.ulRecordLength  = cSdpRecord;

	memcpy (pBigBlob->b.pRecord, rgbSdpRecord, cSdpRecord);
	pBigBlob->b.pRecord[iChannelOffset] = (unsigned char)channel;
	BLOB blob;
	blob.cbSize    = sizeof(BTHNS_SETBLOB) + cSdpRecord - 1;
	blob.pBlobData = (PBYTE) pBigBlob;

	WSAQUERYSET Service;
	memset (&Service, 0, sizeof(Service));
	Service.dwSize = sizeof(Service);
	Service.lpBlob = &blob;
	Service.dwNameSpace = NS_BTH;
	if (WSASetService(&Service,RNRSERVICE_REGISTER,0) == SOCKET_ERROR)
	{
		free(pBigBlob);
		return WSAGetLastError();
	}
	else
	{
		free(pBigBlob);
		return 0;
	}
}

//Function: GetGUID
//Purpose:	Conversts a string containing the GUID into a GUID datatype.
//Input:		string cotaining the GUID
//Output:	GUID type
//Return: Returns -1 in case of an error, otherwise returns zero.

int CWinBlue::GetGUID(WCHAR *psz, GUID *pGUID) 
{
	int data1, data2, data3;
	int data4[8];

	if (11 ==  swscanf(psz, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\n",
					&data1, &data2, &data3,
					&data4[0], &data4[1], &data4[2], &data4[3], 
					&data4[4], &data4[5], &data4[6], &data4[7])) {
		pGUID->Data1 = data1;
		pGUID->Data2 = data2 & 0xffff;
		pGUID->Data3 = data3 & 0xffff;

		for (int i = 0 ; i < 8 ; ++i)
			pGUID->Data4[i] = data4[i] & 0xff;

		return 0;
	}
	return -1;
}

DWORD WINAPI CWinBlue::ScanForNextDevice(LPVOID lpParameter)
{
	CWinBlue *theClass;
	theClass = (CWinBlue *) lpParameter;

	int iResult = WSALookupServiceNext (theClass->hLookup, 
				LUP_RETURN_NAME | LUP_RETURN_ADDR, 
				&theClass->dwSize, 
				theClass->pwsaResults);

	theClass->scanResult = iResult;
	theClass->scanState = 2;
	return iResult;
}


#endif // HAS_MULTIPLAYER && WIN32

#endif