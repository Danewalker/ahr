
#include <windows.h>
#include <stdio.h>
#include <io.h>

#pragma warning(disable:4786)
#define for if(false) ; else for

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

#define DEFINITION_FILE		"Game\\Intl.hpp"
#define REFERENCE_FILE		"bin\\Game\\lang_en.txt"
#define CHAMPIONSHIP_FILE	"Game\\champion.txt"
#define TUNING_FILE			"Game\\tuning.txt"

typedef pair<string, string>			 translation_pair;
typedef pair<unsigned, translation_pair> translation_key;
typedef vector< translation_key >		 translation_list;

translation_list trans;
unsigned		 max_trans;

/*
#define BEGIN_STRINGS										\
	void init_trans()										\
	{


#define STRING_(VALUE, ID, DEFAULT)							\
		trans.push_back(translation_key(VALUE,				\
						 translation_pair(#ID, DEFAULT)))


#define END_STRINGS(MAX)									\
		max_trans = MAX;									\
	}


#include "../../src/HG/Intl.hpp"
*/

string blanks = " \t\n\r";

string clean(const string& s)
{
	return string(&s[s.find_first_not_of(blanks)], &s[s.find_last_not_of(blanks)] + 1);
}

string clean_quotes(const string& s)
{
	if (s.size() < 2)
		return s;
	if (s[0] == '\"')
		if (s[s.size() - 1] == '\"')
			return string(s, 1, s.size() - 2);
	return s;
}

ostream& write_ptr(ostream& o, unsigned i)
{
	o.write((const char*)&i, sizeof(i));
	return o;
}

ostream& write_uchar(ostream& o, unsigned char i)
{
	o.write((const char*)&i, 1);
	return o;
}

string read_string(istream& o)
{
	string s;
	o >> s;
	if (!s.empty() && s[0] == '\"')
	{
		if (s[s.size() - 1] != '\"')
		{
			do
			{
				string s2;
				o >> s2;
				s2 = clean(s2);
				if (!s2.empty())
					s += " " + s2;
			}
			while (s[s.size() - 1] != '\"');
		}
		return string(s, 1, s.size() - 2);
	}
	return s;
}


int main(int argc, char** argv)
{
	if (!(argc == 3 || (argc == 4 && argv[1] == string("-c"))))
	{
		cout << "usage: IntlExp [-c] lang.txt lang.rc" << endl;
		return 0;
	}

	bool check_mode = false;
	char* inFile;
	char* outFile;

	if (argv[1] == string("-c"))
	{
		check_mode = true;
		inFile = argv[2];
		outFile = argv[3];
	}
	else
	{
		inFile = argv[1];
		outFile = argv[2];
	}

	ifstream input(inFile);
	if (input.fail())
	{
		cout << "open input file failed : " << inFile << " : " << strerror(errno) << endl;
		return -1;
	}

	ofstream output(outFile, ofstream::binary);
	if (output.fail())
	{
		cout << "open output file failed : " << outFile << " : " << strerror(errno) << endl;
		return -1;
	}

	// read definition file
	// and output reference translation file
	{
		ifstream defs(DEFINITION_FILE);
		if (defs.fail())
		{
			cout << "open definition file failed : " DEFINITION_FILE " : " << strerror(errno) << endl;
			return -1;
		}

		ifstream champs(CHAMPIONSHIP_FILE);
		if (champs.fail())
		{
			cout << "open championship file failed : " CHAMPIONSHIP_FILE " : " << strerror(errno) << endl;
			return -1;
		}

		ofstream refs(REFERENCE_FILE);
		if (refs.fail())
		{
			cout << "open reference file failed : " REFERENCE_FILE " : " << strerror(errno) << endl;
			return -1;
		}

		refs << "// WARNING: this file is automatically generated, please do not edit." << endl;

		// find BEGIN_STRINGS
		string s;
		bool got_header = false;
		while (!got_header && getline(defs, s))
		{
			s = clean(s);
			if (s == "BEGIN_STRINGS")
				got_header = true;
		}
		if (!got_header)
		{
			cout << DEFINITION_FILE " : invalid definition file (no header)." << endl;
			return -1;
		}

		max_trans = 0;

		bool got_footer = false;
		while (!got_footer && getline(defs, s))	
		{
			s = clean(s);
			if (s.find("END_STRINGS") == 0)
			{
				/*
				istringstream is(&s[0] + string("END_STRINGS(").size());				
				if (!(is >> max_trans))
				{
					cout << DEFINITION_FILE " : invalid definition file (bad footer)." << endl;
					return -1;
				}
				*/
				got_footer = true;
			}
			else
			{
				if (s.find("STRING_(") == 0)
				{
					s = string(s, string("STRING_(").size(), s.size() - string("STRING_(").size() - 2);
					istringstream is(s);
					unsigned id;
					if (!(is >> id))
					{
						cout << DEFINITION_FILE " : invalid id in : " << s << endl;
						return -1;
					}

					string key = clean(string(s, s.find(',') + 1,
												 s.find(',', s.find(',') + 1) - s.find(',') - 1));
					string value = clean(string(s, s.find(',', s.find(',') + 1) + 1, string::npos));
					
					refs << key << string(60 - key.size(), ' ') << value << endl;
					trans.push_back(translation_key(max_trans, translation_pair(key, clean_quotes(value))));
					++max_trans;
				}
				else
					refs << s << endl;
			}
		}
		if (!got_footer)
		{
			cout << DEFINITION_FILE " : invalid definition file (no footer)." << endl;
			return -1;
		}


		// append text from championship file

		bool in_arcade		 = false;
		bool in_categories   = false;
		bool in_championship = false;
		bool in_multichamp	 = false;
		unsigned arcade_count = 1;
		unsigned cat_count = 1;
		unsigned champ_count = 1;
		unsigned multichamp_count = 1;

		while (getline(champs, s))
		{
			s = clean(s);

			// comments
			if (s.empty())
				continue;
			if (string(s, 0, 2) == "//")
				continue;

			if (s == "[ARCADE]")
			{
				in_arcade		= true;
				in_categories	= false;
				in_championship = false;
				in_multichamp	= false;
				continue;
			}
			if (s == "[CATEGORY]")
			{
				in_arcade		= false;
				in_categories	= true;
				in_championship = false;
				in_multichamp	= false;
				continue;
			}
			if (s == "[CHAMPIONSHIP]")
			{
				in_arcade		= false;
				in_categories	= false;
				in_championship = true;
				in_multichamp	= false;
				continue;
			}
			if (s == "[CHAMPIONSHIP_MULTI]")
			{
				in_arcade		= false;
				in_categories	= false;
				in_championship = false;
				in_multichamp	= true;
				continue;
			}
			if (s == "[END]")
			{
				refs << endl;
				in_arcade		= false;
				in_categories	= false;
				in_championship = false;
				in_multichamp	= false;
				continue;
			}

			if (in_arcade)
			{
				istringstream is(s);
				string value = read_string(is);

				string key;
				{
					ostringstream os;
					os << "ARCADE_#" << arcade_count++;
					key = os.str();
				}
				refs << key << string(26 - key.size(), ' ') << '\"' << value << '\"' << endl;
				trans.push_back(translation_key(max_trans, translation_pair(key, value)));
				++max_trans;
			}

			if (in_categories)
			{
				string rest = clean(string(s, s.find(' '), string::npos));				
				string value = string(rest, 1, rest.find('\"', 1) - 1);

				string key;
				{
					ostringstream os;
					os << "CATEGORY_#" << cat_count++;
					key = os.str();
				}
				refs << key << string(26 - key.size(), ' ') << '\"' << value << '\"' << endl;
				trans.push_back(translation_key(max_trans, translation_pair(key, value)));
				++max_trans;

				continue;
			}
			
			if (in_championship)
			{
				string rest = string(s, s.find_first_not_of(blanks, 2), string::npos);
				string value = string(rest, 1, rest.find('\"', 1) - 1);

				string key;
				{
					ostringstream os;
					os << "CHAMPIONSHIP_#" << champ_count++;
					key = os.str();
				}
				refs << key << string(26 - key.size(), ' ') << '\"' << value << '\"' << endl;
				trans.push_back(translation_key(max_trans, translation_pair(key, value)));
				++max_trans;

				continue;
			}

			if (in_multichamp)
			{
				string rest = string(s, s.find_first_not_of(blanks, 2), string::npos);
				string value = string(rest, 1, rest.find('\"', 1) - 1);

				string key;
				{
					ostringstream os;
					os << "CHAMPIONSHIP_MULTI_#" << multichamp_count++;
					key = os.str();
				}
				refs << key << string(26 - key.size(), ' ') << '\"' << value << '\"' << endl;
				trans.push_back(translation_key(max_trans, translation_pair(key, value)));
				++max_trans;

				continue;
			}
		}

		// append text from tuning file
		{
			

			ifstream input(TUNING_FILE);
			if (input.fail())
			{
				cout << "open input file failed : " << TUNING_FILE << " : " << strerror(errno) << endl;
				return -1;
			}

			// read

			unsigned pieces_count = 1;
			unsigned prizes_count = 1;
			unsigned categories_count = 1;

			bool in_pieces	 = false;
			bool in_prize	 = false;
			bool in_category = false;
			bool in_dealers	 = false;

			string s;
			while (getline(input, s))
			{
				s = clean(s);

				// skip comments
				if (s.empty())
					continue;
				if (string(s, 0, 2) == "//")
					continue;

				if (s == "[PIECES]")
				{
					in_pieces	= true;
					in_prize	= false;
					in_category	= false;
					in_dealers	= false;
					continue;
				}
				if (s == "[PRIZE]")
				{
					in_pieces	= false;
					in_prize	= true;
					in_category	= false;
					in_dealers	= false;
					continue;
				}
				if (s == "[CATEGORY]")
				{
					in_pieces	= false;
					in_prize	= false;
					in_category	= true;
					in_dealers	= false;
					continue;
				}
				if (s == "[DEALERS]")
				{
					in_pieces	= false;
					in_prize	= false;
					in_category	= false;
					in_dealers	= true;
					continue;
				}
				if (s == "[END]")
				{
					refs << endl;
					in_pieces	= false;
					in_prize	= false;
					in_category	= false;
					in_dealers	= false;
					continue;
				}


				if (in_pieces)
				{
					istringstream is(s);
					
					// dummy
					unsigned i; is >> i;

					string code;
					is >> code;
					string value = read_string(is);

					string key;
					{
						ostringstream os;
						os << "TUNING_PART_#" << pieces_count++;
						key = os.str();
					}
					refs << key << string(26 - key.size(), ' ') << '\"' << value << '\"' << endl;
					trans.push_back(translation_key(max_trans, translation_pair(key, value)));
					++max_trans;

					continue ;
				}

				if (in_prize)
				{
					istringstream is(s);

					// dummy
					unsigned i; is >> i;

					string value = read_string(is);

					string key;
					{
						ostringstream os;
						os << "TUNING_KIT_#" << prizes_count++;
						key = os.str();
					}
					refs << key << string(26 - key.size(), ' ') << '\"' << value << '\"' << endl;
					trans.push_back(translation_key(max_trans, translation_pair(key, value)));
					++max_trans;
					continue ;
				}

				if (in_category)
				{
					istringstream is(s);

					// dummy
					unsigned i; is >> i;
					
					{
						string value = read_string(is);
						string key;
						{
							ostringstream os;
							os << "TUNING_CATEGORY_#" << categories_count;
							key = os.str();
						}
						refs << key << string(26 - key.size(), ' ') << '\"' << value << '\"' << endl;
						trans.push_back(translation_key(max_trans, translation_pair(key, value)));
						++max_trans;
					}
					{
						string value = read_string(is);
						string key;
						{
							ostringstream os;
							os << "TUNING_CATEGORY_TXT_#" << categories_count++;
							key = os.str();
						}
						refs << key << string(26 - key.size(), ' ') << '\"' << value << '\"' << endl;
						trans.push_back(translation_key(max_trans, translation_pair(key, value)));
						++max_trans;
					}
					continue ;
				}

				if (in_dealers)
				{
					continue ;
				}
			}

		}
	}

	// make up a translation table with default values
	vector<string> trans_table;
	vector<bool> trans_table_check;
	for (unsigned i = 0; i < max_trans; ++i)
	{
		translation_list::iterator it = trans.begin();
		for (; it != trans.end(); ++it)
			if (it->first == i)
			{
				trans_table.push_back(it->second.second);
				break;
			}
		if (it == trans.end())
		{
			cout << "warning: default translation is inconsistent, check Intl.hpp (#"<< i << ")" << endl;
			trans_table.push_back("!!");
		}		
		trans_table_check.push_back(false);
	}

	// read translation file
	string s;
	unsigned line_count = 0;
	while (getline(input, s))
	{
		++line_count;
		s = clean(s);

		// comments
		if (s.empty())
			continue;
		if (string(s, 0, 2) == "//")
			continue;
 		if (strlen(s.c_str()) == 0)
			continue;
 
		// key <spaces> value
		int pos = s.find_first_of(" \t");
		if (pos == string::npos)
			continue;

		string key = clean(string(s, 0, pos));
		string value = clean(string(s, pos+1, string::npos));
		
		// clean up surrounding quotes
		if (value.empty())
			continue;
		value = clean_quotes(value);
		value = clean_quotes(value);
		value = clean_quotes(value);

		while(true)
		{
			int nNewLinePos = value.find_first_of("\\n");
			if (nNewLinePos == string::npos)
				break;
			value.replace(nNewLinePos, 2, "\n");
		}

		// check key is known
		translation_list::iterator it = trans.begin();
		for (; it != trans.end(); ++it)
			if (it->second.first == key)
			{
				trans_table[it->first] = value;
				trans_table_check[it->first] = true;
				break;
			}
		if (it == trans.end())
			cout << "warning: unknown translation " << key << " -> " << value << " in " << inFile << ":" << line_count << endl;
	}

	//
	if (check_mode)
	{
		unsigned count = 0;
		for (unsigned i = 0; i < max_trans; ++i)
			if (!trans_table_check[i])
			{
				++count;
				string key = "unknown!?";
				for (translation_list::iterator it = trans.begin(); it != trans.end(); ++it)
					if (it->first == i)
						key = it->second.first;
				cout << "warning: " << inFile << " : no translation for " << key << endl;
			}
		if (count)
			cout << "error: " << inFile << " : " << count << " translation(s) missing" << endl;
	}

	// write out translation table
	
	unsigned current = sizeof(char*) * (max_trans + 1);

	write_ptr(output, max_trans);

	for (unsigned i = 0; i < max_trans; ++i)
	{
		write_ptr(output, current);
		current += trans_table[i].size() + 1;
	}

	for (unsigned i = 0; i < max_trans; ++i)
	{
		output << trans_table[i];
		write_uchar(output, 0);						
	}

	return 0;
}